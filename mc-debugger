#!/usr/bin/ruby

require 'rubygems'
require 'irb'
require 'mcollective'
require 'tempfile'
require 'pp'


# Stub connector that just logs
class NoopConnector
    def method_missing(*args)
        MCollective::Logger.debug("connector: #{args.pretty_inspect}")
        true
    end
end

def consolize &block
    yield

    IRB.setup(nil)
    irb = IRB::Irb.new
    IRB.conf[:MAIN_CONTEXT] = irb.context
    irb.context.evaluate("require 'irb/completion'", 0)

    install_alias_method :help, :debugger_help, IRB::ExtendCommandBundle::OVERRIDE_ALL

    trap("SIGINT") do
        irb.signal_handle
    end
    catch(:IRB_EXIT) do
        irb.eval_input
    end
end

def debugger_help
    puts <<EOF
    Available Commands:

        call(agent, action, args)       - Calls an action
        printrpc(agent, action, result) - Displays DDL assisted results
        ddl(agent)                      - Shows the ddl help for an agent
        actions(agent)                  - Shows the available actions for an agent
        debugger                        - Start ruby-debugger #{@has_debugger ? '' : '(disabled, install ruby-debugger gem)'}

    Calling Actions:

      To call the status action on the filemgr agent:

         call "filemgr", "status", :file => "/tmp"

    The ddl and actions commands require you to have a DDL for your agent
EOF
end

def load_agent(agent)
    classname = "MCollective::Agent::#{agent.capitalize}"

    MCollective::PluginManager.delete("#{agent}_agent")

    MCollective::PluginManager.loadclass(classname)
    MCollective::PluginManager << {:type => "#{agent}_agent", :class => classname}
end

def setup(configfile="server.cfg")
    # stub the connector with a noop one
    MCollective::PluginManager << {:type => "connector_plugin", :class => "NoopConnector"}

    logger = MCollective::Logger::Console_logger.new
    MCollective::Log.configure(logger)
    logger.set_level(:fatal)

    config = MCollective::Config.instance
    config.loadconfig(configfile) unless config.configured

    logger.set_level(:debug)
end

def printrpc(agent, action, result)
    ddl ||= MCollective::RPC::DDL.new(agent).action_interface(action.to_s)

    ddl[:display] = :always

    puts
    puts MCollective::RPC::Helpers.text_for_result("local_invocation", result[:statuscode], result[:statusmsg], result[:data], ddl)
    puts
rescue Exception => e
    MCollective::Log.warn "Loading the DDL failed: #{e.class}: #{e}"
end

def call(agent, action, request={})
    agent = agent.to_s
    action = action.to_s

    req = {:action => action,
           :agent  => agent}

    req[:data] = request

    load_agent(agent)

    result = MCollective::PluginManager["#{agent}_agent"].handlemsg({:body => req}, MCollective::PluginManager["connector_plugin"])

    printrpc(agent, action, result)

    result
end

def actions(agent)
    ddl = MCollective::RPC::DDL.new(agent)
    ddl.actions.sort
end

def ddl(agent)
    ddl = MCollective::RPC::DDL.new(agent)

    Tempfile.open("ddhelp") do |f|
        f.puts ddl.help(MCollective::Config.instance.rpchelptemplate)
        f.flush
        system("less #{f.path}")
    end
rescue Exception => e
    STDERR.puts "Could not load ddl: #{e.class}: #{e}"
end

consolize do
    configfile = MCollective::Util.config_file_for_user
    configfile = ARGV[0] if ARGV.size == 1

    @has_debugger = false

    begin
        require 'rubygems'
        require 'ruby-debug'
        @has_debugger = true
    end

    setup(configfile)

    puts 'type "help" for help using this debugger'
end
